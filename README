Name: Đỗ Hoàng Quân
MSSV: 2212779
Class: TN02
Teacher: GV Nguyễn Mạnh Thìn

REPORT
OPERATING SYSTEM LAB (CO2018)
LAB 3

Problem 1: Design and implement sequence lock API
---------------------------------------------------
Open folder "ex1seqlock", open terminal and type "make all" to compile
After compiling, open terminal and type "./seqlock" to run file.

Implementation idea: Follow the policy as described in lab 3:
- When no one is in the critical section, one writer can enter the critical section and takes the lock, increasing the sequence number by one to an odd value. When the sequence number is an odd value, the writing is happening. When the writing has been done, the sequence is back to even value. Only one writer is allow into critical section.
- When the reader wants to read data, it checks the sequence number which is an odd value, then it has to wait until the writer finish.
- When the value is even, many readers can enter the critical section to read the value.
- When there are only a reader and no writer in the critical section, if a writer want to enter the critical section it can take the lock without blocking.

To implement struct "pthread_seqlock", I used 3 variable: 1 variable type int, 1 variable type pthread_mutex_t, 1 condition variable type pthread_cond_t.


Problem 2: Aggregated Sum
---------------------------------------------------
Open folder "ex2aggsum", open terminal and type "make all" to compile.
If compile error, possibly beacause of file libutils.a, maybe this file has error when extracting. In this case you can use the file libutils.a i have already submitted (successfully compiled).
After compiling, open terminal and type "./aggsum num1 num2" to run file. Also, num2 should devides num1, in order to get proper result.
num1: number of elements in the array
num2: number of threads

Implementation idea: I fix the signature of function sum_worker, it takes a void pointer so that we can use function pthread_create_thread() with this function. After that we force the type of this pointer into type "struct _range". Next we create "local_sum" to calculate the sum in this range, then use pthread_mutex_lock to the critical section, adding local_sum to sum_buf. Finally I use pthread_mutex_unlock, jump out of the critical section.


Problem 3:Interruptable system logger
---------------------------------------------------
Open folder "ex3logbuf", open terminal and type "make all" to compile
After compiling, open terminal and type "./logbuf" to run file.

I use 2 variable: 1 variable type pthread_mutex_t, 1 condition variable type pthread_cond_t.
The condition variable is used to catch "wrlog" waiting when count >= MAX_BUFFER_SLOT (waitng until function "flushlog" releases signal). When the condition variable isn't used anymore, count will exceed MAX_BUFFER_SLOT.
After function "flushlog" reset, buffer will release signal for function "wrlog". Then I use "pthread_cond_broadcast" hoặc to achieve the same output as the output of lab 3 description. We can also use "pthread_cond_signal" function.
When using "pthread_cond_broadcast", first 6 numbers (0 to 5) will be printed in order. The rest will be printed randomly, with 6 numbers at each time. 
When using "pthread_cond_signal", first 6 numbers (0 to 5) are also printed in order. However, the rest will be printed sequentially, but only 1 number at once.
