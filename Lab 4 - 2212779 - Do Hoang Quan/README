Name: Đỗ Hoàng Quân
MSSV: 2212779
Class: TN02
Teacher: GV Nguyễn Mạnh Thìn

REPORT
OPERATING SYSTEM LAB (CO2018)
LAB 4

Problem 1: Implement the FIFO scheduler policy to bkwrk_get_worker()
---------------------------------------------------
Open folder "Problem 1", open folder "p1threadpool", open terminal and type "make all" to compile.
After compiling, open terminal and type "./mypool" to run file.

Implementation idea: Implement the FIFO scheduler algorithm for function bkwrk_get_worker().
- Iterate through the workers, return the ID of the worker which is currently not busy, or wrkid_busy[i]==0.

Problem 2: Implement another version of the worker using more common fork() API (not Thread based implementation).
---------------------------------------------------
Open folder "Problem 2", open folder "p1threadpool", open terminal and type "make all" to compile.
After compiling, open terminal and type "./mypool" to run file.

Implementation idea: I implement the worker using shared memory.
* File bktpool.h:
- Add an integer variable shmID, and a pointer type "struct bkworker_t" wrk_ptr.
- Add the shared memory module (functions): create_shared_mem(char *proc), attach_shared_mem(char *proc), fill_shared_mem_data(char *proc, int wrk_id), detach_shared_mem(char *proc, struct bkworker_t *shm_ptr).

* File bkwrk.c:
- Comment WORK_THREAD to use fork() API.
- Initiate worker thread with shared memory (#ifdef SHARED_MEMORY ... #endif).
- Implement fork version of create worker (TODO part):
Create a new process using fork() and check for error. Then I declare a signal set for child process, and initialed it to be empty. Next "SIGQUIT" and "SIGUSR1"  are added to the signal set (sigaddset()), I also block those signal from being delivered to this process (sigprocmask(SIG_BLOCK, &set, NULL)). , a message is printed to indicate the worker process ID, worker function is executed (bkwrk_worker((void*)&wrkid)), then exit child process and save it in wrkid_tid[i].
- Function int bkwrk_dispatch_worker(unsigned int wrkid): Implement fork version to signal worker process (TODO part):
+ Worker Function Check: The code first checks if the worker has a valid function assigned to it by checking if worker[wrkid].func is NULL. If the function pointer is NULL, it prints "NULL" and returns -1 to indicate an error.
+ Sending Signal: If the worker has a valid function, it sends a signal (SIG_DISPATCH) to the worker process: kill(wrkid_tid[wrkid], SIG_DISPATCH) sends the signal to the worker process with the PID stored in wrkid_tid[wrkid].
+ Return Value: The function returns 0 to indicate that the signal was successfully sent.

* File Makefile:
- Add share_mem to Makefile

* File shared_mem.c:
- Implement the shared memory module (functions).